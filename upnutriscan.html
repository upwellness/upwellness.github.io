<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>UP NutriScan AI</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font: Noto Sans Thai -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@300;400;500;700;900&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Noto Sans Thai', sans-serif; -webkit-tap-highlight-color: transparent; }
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes pulse-ring { 0% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(13, 148, 136, 0.7); } 70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(13, 148, 136, 0); } 100% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(13, 148, 136, 0); } }
        
        .animate-fadeIn { animation: fadeIn 0.3s ease-out; }
        .animate-slideUp { animation: slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
        .animate-pulse-ring { animation: pulse-ring 2s infinite; }
    </style>

    <!-- Import Map for React & Firebase -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.344.0",
        "firebase/app": "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js",
        "firebase/auth": "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js",
        "firebase/firestore": "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js"
      }
    }
    </script>

    <!-- Babel for JSX (Fixed Version) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
</head>
<body class="bg-slate-50 text-slate-900">
    <div id="root"></div>

    <!-- Fixed: Removed 'env' from data-presets to prevent require() transpilation -->
    <script type="text/babel" data-type="module" data-presets="react">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            Camera, Trash2, Target, Coffee, Sun, Moon, Zap, Info, 
            UtensilsCrossed, Sparkles, Search, PlusCircle, BookOpen, 
            CheckCircle2, Edit2, Save, Download, X, Settings, Flame, 
            ArrowRight, Image as ImageIcon, Scale, Crown, AlertTriangle, Star, Key, 
            PieChart as PieChartIcon, Keyboard, Type
        } from 'lucide-react';
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
        import { getFirestore, collection, doc, setDoc, onSnapshot, deleteDoc } from 'firebase/firestore';

        // --- Configuration ---
        const defaultApiKey = ""; 

        const firebaseConfig = {
            apiKey: "YOUR_FIREBASE_API_KEY",
            authDomain: "YOUR_PROJECT.firebaseapp.com",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_PROJECT.appspot.com",
            messagingSenderId: "YOUR_SENDER_ID",
            appId: "YOUR_APP_ID"
        };

        const activeFirebaseConfig = (typeof __firebase_config !== 'undefined') ? JSON.parse(__firebase_config) : firebaseConfig;
        const appId = (typeof __app_id !== 'undefined') ? __app_id : 'nutri-scan-ai-v4';
        
        let app, auth, db;
        try {
            app = initializeApp(activeFirebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase Init Error: Please check your config.", e);
        }

        const MEAL_TYPES = [
            { id: 'breakfast', label: 'à¸¡à¸·à¹‰à¸­à¹€à¸Šà¹‰à¸²', icon: <Sun size={20} className="text-orange-500" /> },
            { id: 'lunch', label: 'à¸¡à¸·à¹‰à¸­à¹€à¸—à¸µà¹ˆà¸¢à¸‡', icon: <Zap size={20} className="text-yellow-500" /> },
            { id: 'dinner', label: 'à¸¡à¸·à¹‰à¸­à¹€à¸¢à¹‡à¸™', icon: <Moon size={20} className="text-indigo-500" /> },
            { id: 'snack', label: 'à¸¡à¸·à¹‰à¸­à¸§à¹ˆà¸²à¸‡', icon: <Coffee size={20} className="text-emerald-500" /> },
        ];

        function App() {
            const [user, setUser] = useState(null);
            const [activeTab, setActiveTab] = useState('scan');
            const [meals, setMeals] = useState({});
            const [scanResult, setScanResult] = useState(null);
            const [isScanning, setIsScanning] = useState(false);
            const [statusMsg, setStatusMsg] = useState(null);
            const [showPresetModal, setShowPresetModal] = useState(false);
            const [showManualInputModal, setShowManualInputModal] = useState(false);
            const [manualInputText, setManualInputText] = useState('');
            const [manualInputTargetMeal, setManualInputTargetMeal] = useState(null);
            
            // API Key State
            const [apiKey, setApiKey] = useState(defaultApiKey);
            const [showKeyModal, setShowKeyModal] = useState(false);
            const [tempKey, setTempKey] = useState('');

            const [presetConfig, setPresetConfig] = useState({
                bodykey: 1, 
                allPlant: 1, 
                greenTea: 1, 
                targetMeal: 'breakfast'
            });
            
            // Compare Tab States
            const [compareInputs, setCompareInputs] = useState(['', '']);
            const [compareResults, setCompareResults] = useState(null);
            const [isComparing, setIsComparing] = useState(false);

            const fileInputRef = useRef(null);
            const resultCardRef = useRef(null);

            // --- Load API Key ---
            useEffect(() => {
                const storedKey = localStorage.getItem('gemini_api_key');
                if (storedKey) {
                    setApiKey(storedKey);
                } else if (!defaultApiKey) {
                    setShowKeyModal(true);
                }
            }, []);

            const handleSaveKey = () => {
                if (tempKey.trim()) {
                    const key = tempKey.trim();
                    localStorage.setItem('gemini_api_key', key);
                    setApiKey(key);
                    setShowKeyModal(false);
                    setStatusMsg("à¸šà¸±à¸™à¸—à¸¶à¸ API Key à¹à¸¥à¹‰à¸§");
                    setTimeout(() => setStatusMsg(null), 2000);
                }
            };

            // --- Auth & Sync ---
            useEffect(() => {
                if (!auth) return;
                const initAuth = async () => {
                    try {
                        await signInAnonymously(auth);
                    } catch (err) { console.error("Auth failed", err); }
                };
                initAuth();
                const unsubscribe = onAuthStateChanged(auth, setUser);
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                if (!user || !db) return;
                const q = collection(db, 'artifacts', appId, 'users', user.uid, 'daily_meals');
                const unsubscribe = onSnapshot(q, (snapshot) => {
                    const mealData = {};
                    snapshot.forEach(doc => { mealData[doc.id] = doc.data(); });
                    setMeals(mealData);
                }, (error) => console.error("Firestore error:", error));
                return () => unsubscribe();
            }, [user]);

            // --- Image Utility ---
            const resizeImage = (file) => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const MAX_SIZE = 800; 
                            let width = img.width;
                            let height = img.height;

                            if (width > height) {
                                if (width > MAX_SIZE) {
                                    height *= MAX_SIZE / width;
                                    width = MAX_SIZE;
                                }
                            } else {
                                if (height > MAX_SIZE) {
                                    width *= MAX_SIZE / height;
                                    height = MAX_SIZE;
                                }
                            }

                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            resolve(canvas.toDataURL('image/jpeg', 0.7)); 
                        };
                    };
                });
            };

            // --- Helper: Create Placeholder Image for Text Input ---
            const createPlaceholderImage = (text) => {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                const ctx = canvas.getContext('2d');

                // Background gradient
                const grd = ctx.createLinearGradient(0, 0, 800, 600);
                grd.addColorStop(0, '#ccfbf1'); // teal-100
                grd.addColorStop(1, '#f0fdfa'); // teal-50
                ctx.fillStyle = grd;
                ctx.fillRect(0, 0, 800, 600);

                // Text
                ctx.fillStyle = '#0f766e'; // teal-700
                ctx.font = 'bold 80px "Noto Sans Thai", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text.substring(0, 20), 400, 300);
                
                ctx.font = '40px "Noto Sans Thai", sans-serif';
                ctx.fillStyle = '#99f6e4';
                ctx.fillText("AI Generated Estimate", 400, 380);

                return canvas.toDataURL('image/jpeg', 0.7);
            };

            // --- AI Analysis Logic ---
            const analyzeImage = async (file) => {
                if (!apiKey) {
                    setShowKeyModal(true);
                    return;
                }
                setIsScanning(true);
                setStatusMsg("UP AI à¸à¸³à¸¥à¸±à¸‡à¸¢à¹ˆà¸­à¹„à¸Ÿà¸¥à¹Œà¹à¸¥à¸°à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ...");
                
                try {
                    const base64Image = await resizeImage(file);
                    
                    const systemPrompt = `à¸„à¸¸à¸“à¸„à¸·à¸­à¸œà¸¹à¹‰à¹€à¸Šà¸µà¹ˆà¸¢à¸§à¸Šà¸²à¸à¸”à¹‰à¸²à¸™à¹‚à¸ à¸Šà¸™à¸²à¸à¸²à¸£ à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸£à¸¹à¸›à¸ à¸²à¸žà¸­à¸²à¸«à¸²à¸£à¸­à¸¢à¹ˆà¸²à¸‡à¸¥à¸°à¹€à¸­à¸µà¸¢à¸” à¹à¸¢à¸à¹à¸¢à¸°à¸ªà¹ˆà¸§à¸™à¸›à¸£à¸°à¸à¸­à¸š (Components) à¹ƒà¸™à¸ˆà¸²à¸™
                    à¹ƒà¸«à¹‰à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œà¹€à¸›à¹‡à¸™ JSON à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™:
                    {
                        "foodName": "à¸Šà¸·à¹ˆà¸­à¹€à¸¡à¸™à¸¹à¸«à¸¥à¸±à¸",
                        "total_calories": number,
                        "total_carbs_g": number,
                        "total_protein_g": number,
                        "total_fat_g": number,
                        "components": [
                        { "name": "à¸Šà¸·à¹ˆà¸­à¸§à¸±à¸•à¸–à¸¸à¸”à¸´à¸š (à¹€à¸Šà¹ˆà¸™ à¸‚à¹‰à¸²à¸§à¸ªà¸§à¸¢, à¸›à¸¥à¸²à¸—à¸¹à¸—à¸­à¸”)", "weight_g": à¸›à¸£à¸´à¸¡à¸²à¸“à¹€à¸›à¹‡à¸™à¸à¸£à¸±à¸¡à¹‚à¸”à¸¢à¸›à¸£à¸°à¸¡à¸²à¸“, "carbs_g": number, "protein_g": number, "fat_g": number, "calories": number }
                        ]
                    }`;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                        contents: [{
                            parts: [
                            { text: "à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¸ à¸²à¸žà¸™à¸µà¹‰à¹à¸šà¸šà¸¥à¸°à¹€à¸­à¸µà¸¢à¸” à¹à¸¢à¸à¸ªà¹ˆà¸§à¸™à¸›à¸£à¸°à¸à¸­à¸š" },
                            { inlineData: { mimeType: "image/jpeg", data: base64Image.split(',')[1] } }
                            ]
                        }],
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        generationConfig: { responseMimeType: "application/json" }
                        })
                    });
                    
                    if (!response.ok) {
                        let errorMsg = await response.text();
                        try {
                            const errorObj = JSON.parse(errorMsg);
                            errorMsg = errorObj.error?.message || errorMsg;
                        } catch(e) {}
                        
                        if (errorMsg.includes("blocked") || errorMsg.includes("referer")) {
                             throw new Error("API Key à¸–à¸¹à¸à¸šà¸¥à¹‡à¸­à¸ (Referer Blocked) à¸à¸£à¸¸à¸“à¸²à¹ƒà¸Šà¹‰ Key à¹à¸šà¸šà¹„à¸¡à¹ˆà¸ˆà¸³à¸à¸±à¸”à¸ªà¸´à¸—à¸˜à¸´à¹Œ");
                        }
                        throw new Error(`API Error: ${errorMsg}`);
                    }

                    const result = await response.json();
                    if (!result.candidates || !result.candidates[0].content) {
                         throw new Error("AI did not return any content.");
                    }
                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    
                    processAndSetScanResult(data, base64Image);
                } catch (error) {
                    setStatusMsg(error.message);
                    console.error(error);
                    if (error.message.includes("API Key") || error.message.includes("403") || error.message.includes("blocked")) {
                        setShowKeyModal(true);
                    }
                } finally {
                    setIsScanning(false);
                }
            };

            const analyzeTextMenu = async () => {
                if (!apiKey) {
                    setShowKeyModal(true);
                    return;
                }
                if (!manualInputText.trim()) return;

                setIsScanning(true);
                setStatusMsg(`UP AI à¸à¸³à¸¥à¸±à¸‡à¸„à¸³à¸™à¸§à¸“à¸ªà¸²à¸£à¸­à¸²à¸«à¸²à¸£à¸‚à¸­à¸‡ "${manualInputText}"...`);
                setShowManualInputModal(false); // Close modal

                try {
                    const prompt = `
                    à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸ªà¸²à¸£à¸­à¸²à¸«à¸²à¸£à¸‚à¸­à¸‡à¹€à¸¡à¸™à¸¹: "${manualInputText}" à¹‚à¸”à¸¢à¸¥à¸°à¹€à¸­à¸µà¸¢à¸” (à¸›à¸£à¸´à¸¡à¸²à¸“ 1 à¸ˆà¸²à¸™à¸›à¸à¸•à¸´)
                    à¹ƒà¸«à¹‰à¸œà¸¥à¸¥à¸±à¸žà¸˜à¹Œà¹€à¸›à¹‡à¸™ JSON à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™:
                    {
                        "foodName": "${manualInputText}",
                        "total_calories": number,
                        "total_carbs_g": number,
                        "total_protein_g": number,
                        "total_fat_g": number,
                        "components": [
                        { "name": "à¸Šà¸·à¹ˆà¸­à¸§à¸±à¸•à¸–à¸¸à¸”à¸´à¸š (à¹€à¸Šà¹ˆà¸™ à¸‚à¹‰à¸²à¸§à¸ªà¸§à¸¢, à¹€à¸™à¸·à¹‰à¸­à¸ªà¸±à¸•à¸§à¹Œ)", "weight_g": number, "carbs_g": number, "protein_g": number, "fat_g": number, "calories": number }
                        ]
                    }`;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { responseMimeType: "application/json" }
                        })
                    });

                    if (!response.ok) {
                        let errorMsg = await response.text();
                         try {
                            const errorObj = JSON.parse(errorMsg);
                            errorMsg = errorObj.error?.message || errorMsg;
                        } catch(e) {}
                        throw new Error(`API Error: ${errorMsg}`);
                    }

                    const result = await response.json();
                    if (!result.candidates || !result.candidates[0].content) {
                         throw new Error("AI did not return any content.");
                    }
                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    
                    // Generate placeholder image
                    const placeholderImg = createPlaceholderImage(manualInputText);
                    
                    // Set result and redirect to scan tab (which acts as result view)
                    processAndSetScanResult(data, placeholderImg);
                    setActiveTab('scan'); 

                } catch (error) {
                    setStatusMsg("à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œà¹€à¸¡à¸™à¸¹à¸™à¸µà¹‰à¹„à¸”à¹‰: " + error.message);
                    if (error.message.includes("API Key") || error.message.includes("blocked")) {
                        setShowKeyModal(true);
                    }
                } finally {
                    setIsScanning(false);
                    setManualInputText('');
                }
            };

            const processAndSetScanResult = (data, imageSrc) => {
                const componentsWithRatios = (data.components || []).map(c => ({
                    ...c,
                    ratio_c: c.weight_g ? c.carbs_g / c.weight_g : 0,
                    ratio_p: c.weight_g ? c.protein_g / c.weight_g : 0,
                    ratio_f: c.weight_g ? c.fat_g / c.weight_g : 0,
                    ratio_kcal: c.weight_g ? c.calories / c.weight_g : 0
                }));

                const normalizedData = {
                    foodName: data.foodName,
                    carbs_g: data.total_carbs_g,
                    protein_g: data.total_protein_g,
                    fat_g: data.total_fat_g,
                    calories: data.total_calories,
                    components: componentsWithRatios,
                    image: imageSrc,
                    timestamp: Date.now()
                };

                setScanResult(normalizedData);
                setStatusMsg(null);
            };

            const updateComponentWeight = (index, newWeight) => {
                if (!scanResult) return;
                const updatedComponents = [...scanResult.components];
                const comp = updatedComponents[index];
                const weight = parseFloat(newWeight) || 0;

                comp.weight_g = weight;
                comp.carbs_g = Math.round(weight * comp.ratio_c);
                comp.protein_g = Math.round(weight * comp.ratio_p);
                comp.fat_g = Math.round(weight * comp.ratio_f);
                comp.calories = Math.round(weight * comp.ratio_kcal);

                const totals = updatedComponents.reduce((acc, curr) => ({
                    c: acc.c + curr.carbs_g,
                    p: acc.p + curr.protein_g,
                    f: acc.f + curr.fat_g,
                    kcal: acc.kcal + curr.calories
                }), { c: 0, p: 0, f: 0, kcal: 0 });

                setScanResult({
                    ...scanResult,
                    components: updatedComponents,
                    carbs_g: totals.c,
                    protein_g: totals.p,
                    fat_g: totals.f,
                    calories: totals.kcal
                });
            };

            // --- Compare Logic ---
            const handleCompare = async () => {
                if (!apiKey) {
                    setShowKeyModal(true);
                    return;
                }

                const menusToCompare = compareInputs.filter(m => m.trim() !== "");
                if (menusToCompare.length < 2) {
                    setStatusMsg("à¸à¸£à¸¸à¸“à¸²à¹ƒà¸ªà¹ˆà¸Šà¸·à¹ˆà¸­à¹€à¸¡à¸™à¸¹à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 2 à¸£à¸²à¸¢à¸à¸²à¸£");
                    return;
                }

                setIsComparing(true);
                setStatusMsg("AI à¸à¸³à¸¥à¸±à¸‡à¸›à¸£à¸°à¸Šà¸±à¸™à¹€à¸¡à¸™à¸¹...");

                try {
                    const prompt = `
                    à¹€à¸›à¸£à¸µà¸¢à¸šà¹€à¸—à¸µà¸¢à¸šà¹€à¸¡à¸™à¸¹à¸­à¸²à¸«à¸²à¸£à¹€à¸«à¸¥à¹ˆà¸²à¸™à¸µà¹‰: ${menusToCompare.join(", ")}
                    à¸›à¸£à¸°à¸¡à¸²à¸“à¸à¸²à¸£à¸ªà¸²à¸£à¸­à¸²à¸«à¸²à¸£à¸•à¹ˆà¸­ 1 à¸ˆà¸²à¸™à¸›à¸à¸•à¸´:
                    1. Calories (kcal)
                    2. Carbs (g)
                    3. Protein (g)
                    4. Fat (g)
                    5. Insulin Spike Score (0-100, à¹‚à¸”à¸¢ 0 à¸„à¸·à¸­à¸”à¸µà¸¡à¸²à¸/à¹„à¸¡à¹ˆà¸à¸£à¸°à¸•à¸¸à¹‰à¸™, 100 à¸„à¸·à¸­à¹à¸¢à¹ˆà¸¡à¸²à¸/à¸à¸£à¸°à¸•à¸¸à¹‰à¸™à¸ªà¸¹à¸‡) à¸žà¸´à¸ˆà¸²à¸£à¸“à¸²à¸ˆà¸²à¸ GI, GL à¹à¸¥à¸°à¸›à¸£à¸´à¸¡à¸²à¸“ Carb
                    
                    à¸•à¸­à¸šà¹€à¸›à¹‡à¸™ JSON Array à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™:
                    [
                        { "name": "à¸Šà¸·à¹ˆà¸­à¹€à¸¡à¸™à¸¹", "kcal": number, "c": number, "p": number, "f": number, "insulin_score": number, "insulin_desc": "à¸„à¸³à¸­à¸˜à¸´à¸šà¸²à¸¢à¸ªà¸±à¹‰à¸™à¹†à¹€à¸£à¸·à¹ˆà¸­à¸‡à¸­à¸´à¸™à¸‹à¸¹à¸¥à¸´à¸™" }
                    ]
                    `;

                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ parts: [{ text: prompt }] }],
                            generationConfig: { responseMimeType: "application/json" }
                        })
                    });

                    if (!response.ok) {
                        let errorMessage = `API Error (${response.status})`;
                        try {
                            const errData = await response.json();
                            if (errData.error && errData.error.message) {
                                errorMessage = errData.error.message;
                            }
                        } catch (e) {}

                        if (response.status === 400 || response.status === 403) {
                            setShowKeyModal(true);
                            throw new Error("API Key à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¸«à¸£à¸·à¸­à¹‚à¸¡à¹€à¸”à¸¥à¹„à¸¡à¹ˆà¸£à¸­à¸‡à¸£à¸±à¸š: " + errorMessage);
                        }
                        throw new Error(errorMessage);
                    }

                    const result = await response.json();
                    if (!result.candidates || !result.candidates[0].content) {
                         throw new Error("AI à¹„à¸¡à¹ˆà¸ªà¹ˆà¸‡à¸„à¸³à¸•à¸­à¸šà¸à¸¥à¸±à¸šà¸¡à¸²");
                    }
                    const data = JSON.parse(result.candidates[0].content.parts[0].text);
                    
                    setCompareResults(data);
                    setStatusMsg(null);
                } catch (e) {
                    console.error(e);
                    setStatusMsg("à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”: " + e.message);
                } finally {
                    setIsComparing(false);
                }
            };

            const getBestInClass = (data) => {
                if (!data || data.length === 0) return {};
                const minKcal = Math.min(...data.map(d => d.kcal));
                const minCarb = Math.min(...data.map(d => d.c));
                const maxProt = Math.max(...data.map(d => d.p));
                const minFat = Math.min(...data.map(d => d.f));
                const minInsulin = Math.min(...data.map(d => d.insulin_score));
                return { minKcal, minCarb, maxProt, minFat, minInsulin };
            };

            const determineWinner = (data) => {
                if (!data || data.length === 0) return -1;
                let bestScore = -Infinity;
                let winnerIndex = -1;
                data.forEach((item, idx) => {
                    const score = (item.p * 2) - item.c - (item.f * 0.5) - (item.insulin_score * 0.5);
                    if (score > bestScore) {
                        bestScore = score;
                        winnerIndex = idx;
                    }
                });
                return winnerIndex;
            }

            // --- Presets ---
            const calculatePreset = () => {
                const bk = presetConfig.bodykey * 1; 
                const bk_c = 17 * bk; const bk_p = 17 * bk; const bk_f = 6 * bk; const bk_kcal = 200 * bk;
                const ap = presetConfig.allPlant * 1;
                const ap_c = 0.5 * ap; const ap_p = 13.5 * ap; const ap_f = 0.5 * ap; const ap_kcal = 65 * ap;
                const gt = presetConfig.greenTea * 1;
                const gt_c = 1 * gt; const gt_p = 4 * gt; const gt_f = 0 * gt; const gt_kcal = 25 * gt;

                return {
                    foodName: `UP Set: Bodykey x${bk} + AP x${ap} + GT x${gt}`,
                    carbs_g: Math.round(bk_c + ap_c + gt_c),
                    protein_g: Math.round(bk_p + ap_p + gt_p),
                    fat_g: Math.round(bk_f + ap_f + gt_f),
                    calories: Math.round(bk_kcal + ap_kcal + gt_kcal),
                    isPreset: true,
                    timestamp: Date.now()
                };
            };

            const savePreset = async () => {
                if (!user) {
                    setStatusMsg("à¸à¸³à¸¥à¸±à¸‡à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸£à¸°à¸šà¸š à¸à¸£à¸¸à¸“à¸²à¸£à¸­à¸ªà¸±à¸à¸„à¸£à¸¹à¹ˆ...");
                    return;
                }
                const mealId = presetConfig.targetMeal;
                const data = calculatePreset();
                setStatusMsg(`à¸à¸³à¸¥à¸±à¸‡à¸šà¸±à¸™à¸—à¸¶à¸ ${data.foodName}...`);
                try {
                    await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'daily_meals', mealId), data);
                    setShowPresetModal(false);
                    setStatusMsg("à¸šà¸±à¸™à¸—à¸¶à¸à¸ªà¸³à¹€à¸£à¹‡à¸ˆ!");
                    setTimeout(() => setStatusMsg(null), 1500);
                    setActiveTab('diary');
                } catch (e) {
                    setStatusMsg("à¸šà¸±à¸™à¸—à¸¶à¸à¹„à¸¡à¹ˆà¸ªà¸³à¹€à¸£à¹‡à¸ˆ: " + e.message);
                }
            };

            const saveToDiary = async (mealId) => {
                if (!user) {
                    setStatusMsg("à¸à¸£à¸¸à¸“à¸²à¸£à¸­à¸£à¸°à¸šà¸šà¸¢à¸·à¸™à¸¢à¸±à¸™à¸•à¸±à¸§à¸•à¸™à¸ªà¸±à¸à¸„à¸£à¸¹à¹ˆ...");
                    return;
                }
                if (!scanResult) {
                    setStatusMsg("à¹„à¸¡à¹ˆà¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¹ƒà¸«à¹‰à¸šà¸±à¸™à¸—à¸¶à¸");
                    return;
                }
                setStatusMsg(`à¸à¸³à¸¥à¸±à¸‡à¸šà¸±à¸™à¸—à¸¶à¸...`);
                try {
                    await setDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'daily_meals', mealId), scanResult);
                    setStatusMsg(`à¸šà¸±à¸™à¸—à¸¶à¸à¸¥à¸‡ ${MEAL_TYPES.find(m => m.id === mealId).label} à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢`);
                    setScanResult(null);
                    setActiveTab('diary');
                    setTimeout(() => setStatusMsg(null), 2000);
                } catch (error) {
                    console.error(error);
                    setStatusMsg("à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸šà¸±à¸™à¸—à¸¶à¸: " + error.message);
                }
            };

            const deleteMeal = async (mealId) => {
                if (!user) return;
                await deleteDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'daily_meals', mealId));
            };

            // --- Professional Image Generation ---
            const downloadImage = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.src = scanResult.image;

                document.fonts.load('bold 34px "Noto Sans Thai"').then(() => {
                    img.onload = () => {
                        const width = 1200; 
                        const scale = width / img.width;
                        const imgHeight = img.height * scale;
                        
                        const padding = 60;
                        const headerHeight = 160; 
                        const contentStart = headerHeight + imgHeight + padding;
                        
                        const rowHeight = 140; 
                        const componentsCount = scanResult.components.length;
                        const componentsSectionHeight = (componentsCount * rowHeight) + 180; 
                        const totalHeight = contentStart + 450 + componentsSectionHeight + 150;

                        canvas.width = width;
                        canvas.height = totalHeight;

                        const grd = ctx.createLinearGradient(0, 0, 0, totalHeight);
                        grd.addColorStop(0, '#f8fafc'); 
                        grd.addColorStop(1, '#e2e8f0'); 
                        ctx.fillStyle = grd;
                        ctx.fillRect(0, 0, width, totalHeight);

                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, width, headerHeight);
                        
                        ctx.fillStyle = '#0d9488';
                        ctx.font = 'bold 50px "Noto Sans Thai", sans-serif';
                        ctx.fillText("UP NutriScan", padding, 100);
                        
                        ctx.fillStyle = '#94a3b8';
                        ctx.font = '36px "Noto Sans Thai", sans-serif';
                        ctx.textAlign = 'right';
                        ctx.fillText("AI Food Analysis", width - padding, 100);
                        ctx.textAlign = 'left';
                        
                        ctx.drawImage(img, 0, headerHeight, width, imgHeight);

                        let currentY = contentStart;
                        ctx.fillStyle = '#1e293b'; 
                        ctx.font = 'bold 80px "Noto Sans Thai", sans-serif';
                        ctx.fillText(scanResult.foodName, padding, currentY);
                        
                        currentY += 120;
                        const cardWidth = (width - (padding * 2) - 60) / 4; 
                        
                        const drawStatCard = (label, val, unit, color, x) => {
                            ctx.fillStyle = 'rgba(0,0,0,0.05)';
                            ctx.fillRect(x+10, currentY+10, cardWidth, 220);
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(x, currentY, cardWidth, 220);
                            ctx.fillStyle = color;
                            ctx.fillRect(x, currentY, cardWidth, 12);
                            ctx.fillStyle = '#64748b';
                            ctx.font = 'bold 28px "Noto Sans Thai", sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(label, x + cardWidth/2, currentY + 60);
                            ctx.fillStyle = '#0f172a';
                            ctx.font = 'bold 64px "Noto Sans Thai", sans-serif';
                            ctx.fillText(val, x + cardWidth/2, currentY + 140);
                            ctx.font = '24px "Noto Sans Thai", sans-serif';
                            ctx.fillStyle = '#94a3b8';
                            ctx.fillText(unit, x + cardWidth/2, currentY + 180);
                            ctx.textAlign = 'left';
                        };

                        drawStatCard("CALORIES", scanResult.calories, "kcal", '#0d9488', padding);
                        drawStatCard("PROTEIN", scanResult.protein_g, "g", '#f43f5e', padding + cardWidth + 20); 
                        drawStatCard("CARBS", scanResult.carbs_g, "g", '#f97316', padding + (cardWidth + 20)*2); 
                        drawStatCard("FAT", scanResult.fat_g, "g", '#f59e0b', padding + (cardWidth + 20)*3); 

                        currentY += 320;
                        ctx.fillStyle = '#334155';
                        ctx.font = 'bold 44px "Noto Sans Thai", sans-serif';
                        ctx.fillText("Detailed Breakdown (à¹à¸¢à¸à¸­à¸‡à¸„à¹Œà¸›à¸£à¸°à¸à¸­à¸š)", padding, currentY);
                        
                        currentY += 60;
                        ctx.fillStyle = '#cbd5e1';
                        ctx.fillRect(padding, currentY, width - padding*2, 80);
                        ctx.fillStyle = '#475569';
                        ctx.font = 'bold 30px "Noto Sans Thai", sans-serif';
                        ctx.fillText("ITEM / à¸£à¸²à¸¢à¸à¸²à¸£", padding + 30, currentY + 50);
                        ctx.textAlign = 'right';
                        ctx.fillText("WEIGHT / à¸™à¹‰à¸³à¸«à¸™à¸±à¸", width - padding - 30, currentY + 50);
                        ctx.textAlign = 'left';

                        currentY += 80;
                        
                        scanResult.components.forEach((comp, i) => {
                            ctx.fillStyle = i % 2 === 0 ? '#ffffff' : '#f1f5f9';
                            ctx.fillRect(padding, currentY, width - padding*2, rowHeight);
                            ctx.fillStyle = '#1e293b';
                            ctx.font = 'bold 36px "Noto Sans Thai", sans-serif';
                            ctx.fillText(comp.name, padding + 30, currentY + 55);
                            ctx.textAlign = 'right';
                            ctx.fillStyle = '#64748b';
                            ctx.font = '36px "Noto Sans Thai", sans-serif';
                            ctx.fillText(`${comp.weight_g} g`, width - padding - 30, currentY + 55);
                            ctx.textAlign = 'left';
                            ctx.font = '28px "Noto Sans Thai", sans-serif';
                            const drawMacroText = (text, x, color) => {
                                ctx.fillStyle = color;
                                ctx.fillText(text, x, currentY + 105);
                            };
                            let startX = padding + 30;
                            drawMacroText(`ðŸ”¥ ${comp.calories} kcal`, startX, '#64748b'); 
                            startX += 220;
                            drawMacroText(`ðŸ¥© P: ${comp.protein_g}g`, startX, '#be123c'); 
                            startX += 180;
                            drawMacroText(`ðŸš C: ${comp.carbs_g}g`, startX, '#c2410c'); 
                            startX += 180;
                            drawMacroText(`ðŸ¥‘ F: ${comp.fat_g}g`, startX, '#b45309'); 
                            currentY += rowHeight;
                        });

                        const footerY = totalHeight - 120;
                        ctx.fillStyle = '#cbd5e1';
                        ctx.fillRect(padding + 100, footerY, width - (padding*2 + 200), 2); 
                        ctx.fillStyle = '#64748b';
                        ctx.font = '32px "Noto Sans Thai", sans-serif';
                        ctx.textAlign = 'center';
                        const dateStr = new Date().toLocaleDateString('th-TH', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute:'2-digit'});
                        ctx.fillText(`Scanned on ${dateStr}`, width/2, footerY + 60);
                        ctx.fillStyle = '#0d9488';
                        ctx.font = 'bold 32px "Noto Sans Thai", sans-serif';
                        ctx.fillText("Generated by UP NutriScan App", width/2, footerY + 110);

                        const link = document.createElement('a');
                        link.download = `UP-NutriScan-${Date.now()}.jpg`;
                        link.href = canvas.toDataURL('image/jpeg', 0.95);
                        link.click();
                    };
                    if (img.complete && img.naturalHeight !== 0) img.onload();
                });
            };

            const getDailyStats = () => {
                return Object.values(meals).reduce((acc, curr) => {
                acc.c += (curr.carbs_g || 0);
                acc.p += (curr.protein_g || 0);
                acc.f += (curr.fat_g || 0);
                acc.kcal += (curr.calories || 0);
                return acc;
                }, { c: 0, p: 0, f: 0, kcal: 0 });
            };

            const stats = getDailyStats();
            const totalGrams = (stats.c * 4) + (stats.p * 4) + (stats.f * 9);
            const pPct = totalGrams ? Math.round(((stats.p * 4) / totalGrams) * 100) : 0;
            const cPct = totalGrams ? Math.round(((stats.c * 4) / totalGrams) * 100) : 0;
            const fPct = totalGrams ? Math.round(((stats.f * 9) / totalGrams) * 100) : 0;

            const getModeInfo = (p, c, f) => {
                if (stats.kcal === 0) return { label: "UP Start", color: "text-slate-400" };
                if (p >= 35 && c <= 45 && f <= 35) return { label: "Fat Burn Mode", color: "text-rose-500", key: 'WL' };
                if (p >= 30 && c >= 40 && f <= 25) return { label: "Muscle Build Mode", color: "text-indigo-500", key: 'MG' };
                return { label: "Maintenance", color: "text-emerald-500", key: 'MT' };
            };

            const mode = getModeInfo(pPct, cPct, fPct);

            const getMealAdvice = (mealData) => {
                if (!mealData || mealData.isPreset) return null;
                const totalKcal = mealData.calories;
                if (totalKcal === 0) return null;
                const pPct = (mealData.protein_g * 4 / totalKcal) * 100;
                const cPct = (mealData.carbs_g * 4 / totalKcal) * 100;
                const fPct = (mealData.fat_g * 9 / totalKcal) * 100;
                const suggestions = [];
                
                if (cPct > 45) {
                    suggestions.push("à¸¥à¸”à¸›à¸£à¸´à¸¡à¸²à¸“à¹à¸›à¹‰à¸‡/à¸™à¹‰à¸³à¸•à¸²à¸¥");
                }
                if (fPct > 35) {
                    suggestions.push("à¸¥à¸”à¸‚à¸­à¸‡à¸¡à¸±à¸™/à¸‚à¸­à¸‡à¸—à¸­à¸”");
                }
                if (pPct < 35) suggestions.push("à¹€à¸žà¸´à¹ˆà¸¡à¹‚à¸›à¸£à¸•à¸µà¸™ (à¹„à¸‚à¹ˆ/à¹€à¸™à¸·à¹‰à¸­à¸ªà¸±à¸•à¸§à¹Œ)");

                if (suggestions.length === 0) return { status: 'good', text: "à¸¡à¸·à¹‰à¸­à¸™à¸µà¹‰à¸ªà¸±à¸”à¸ªà¹ˆà¸§à¸™à¸”à¸µà¹€à¸¢à¸µà¹ˆà¸¢à¸¡!" };
                return { status: 'warning', text: suggestions.join(", ") };
            };

            // --- Sub Components ---
            function NavButton({ active, onClick, icon, label }) {
                return (
                    <button 
                    onClick={onClick}
                    className={`flex flex-col items-center gap-1 transition-all ${active ? 'text-teal-600 -translate-y-1' : 'text-slate-300 hover:text-slate-400'}`}
                    >
                    <div className={`p-2 rounded-2xl ${active ? 'bg-teal-50 shadow-sm' : ''}`}>
                        {icon}
                    </div>
                    <span className="text-[10px] font-bold tracking-wide">{label}</span>
                    </button>
                );
            }

            function MacroPill({ label, val, color }) {
                return (
                    <div className={`flex flex-col items-center justify-center p-2 rounded-xl ${color}`}>
                    <span className="text-[10px] font-bold uppercase opacity-70">{label}</span>
                    <span className="text-lg font-black leading-none mt-1">{val}g</span>
                    </div>
                );
            }

            function MacroBox({ label, val, totalG, color }) {
                const pct = totalG ? Math.round(((val * (label === 'FAT' ? 9 : 4)) / totalG) * 100) : 0;
                return (
                    <div className="bg-slate-50 p-3 rounded-2xl border border-slate-100 flex flex-col items-center text-center">
                    <span className={`text-[9px] font-black mb-1 px-2 py-0.5 rounded-full text-white ${color}`}>{label}</span>
                    <span className="text-xl font-black text-slate-800">{val}<span className="text-[10px] font-normal ml-0.5 text-slate-400">g</span></span>
                    <span className="text-[10px] font-bold text-slate-400 mt-1">{pct}%</span>
                    </div>
                );
            }

            function MacroDonutChart({ carbs, protein, fat }) {
                const cCal = carbs * 4;
                const pCal = protein * 4;
                const fCal = fat * 9;
                const total = cCal + pCal + fCal;

                if (total === 0) return null;

                const slices = [
                    { label: 'Carbs', value: cCal, raw: carbs, color: '#f97316', percent: cCal / total }, // Orange
                    { label: 'Protein', value: pCal, raw: protein, color: '#f43f5e', percent: pCal / total }, // Rose
                    { label: 'Fat', value: fCal, raw: fat, color: '#f59e0b', percent: fCal / total }, // Amber
                ].filter(s => s.percent > 0);

                let cumulativePercent = 0;

                const getCoordinatesForPercent = (percent) => {
                    const x = Math.cos(2 * Math.PI * percent);
                    const y = Math.sin(2 * Math.PI * percent);
                    return [x, y];
                }

                return (
                    <div className="flex items-center justify-center gap-6 py-6 border-b border-slate-100 mb-6">
                        <div className="relative w-32 h-32 shrink-0">
                            <svg viewBox="-1 -1 2 2" className="rotate-[-90deg] w-full h-full">
                                {slices.map((slice, i) => {
                                    if (slice.percent === 1) {
                                        return <circle key={i} cx="0" cy="0" r="1" fill={slice.color} />;
                                    }
                                    const [startX, startY] = getCoordinatesForPercent(cumulativePercent);
                                    cumulativePercent += slice.percent;
                                    const [endX, endY] = getCoordinatesForPercent(cumulativePercent);
                                    const largeArcFlag = slice.percent > 0.5 ? 1 : 0;
                                    const pathData = [
                                        `M 0 0`,
                                        `L ${startX} ${startY}`,
                                        `A 1 1 0 ${largeArcFlag} 1 ${endX} ${endY}`,
                                        `Z`
                                    ].join(' ');
                                    return <path key={i} d={pathData} fill={slice.color} />;
                                })}
                                <circle cx="0" cy="0" r="0.75" fill="white" />
                            </svg>
                            <div className="absolute inset-0 flex items-center justify-center flex-col">
                                <span className="text-[10px] font-bold text-slate-400 uppercase tracking-widest">Total</span>
                                <div className="flex items-baseline">
                                    <span className="text-xl font-black text-slate-700">{Math.round(total)}</span>
                                    <span className="text-[9px] font-bold text-slate-400 ml-0.5">kcal</span>
                                </div>
                            </div>
                        </div>
                        
                        <div className="flex-1 space-y-2">
                            {slices.map((slice, i) => (
                                <div key={i} className="flex items-center justify-between">
                                    <div className="flex items-center gap-2">
                                        <div className="w-2.5 h-2.5 rounded-full" style={{ backgroundColor: slice.color }}></div>
                                        <span className="text-xs font-bold text-slate-600">{slice.label}</span>
                                    </div>
                                    <div className="text-right">
                                        <p className="text-xs font-black text-slate-700">{Math.round(slice.percent * 100)}%</p>
                                        <p className="text-[9px] text-slate-400 font-medium">{Math.round(slice.value)} kcal</p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            }

            const root = createRoot(document.getElementById('root'));
            root.render(<App />);
    </script>
</body>
</html>
