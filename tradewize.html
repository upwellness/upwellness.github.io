<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradeWise Pro 2.6 - Ultimate Analysis</title>
    
    <!-- React & Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.js" crossorigin></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Kanit', sans-serif; background-color: #020617; color: #e2e8f0; }
        .mono { font-family: 'JetBrains Mono', monospace; }
        .glass-panel {
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }
        .chart-box { height: 500px; width: 100%; position: relative; }
        .mini-chart-box { height: 160px; width: 100%; border-radius: 8px; overflow: hidden; background: #0f172a; border: 1px solid #1e293b; }
        .active-tf { border-color: #3b82f6; background: rgba(59, 130, 246, 0.15); box-shadow: 0 0 20px rgba(59, 130, 246, 0.25); transform: translateY(-2px); }
        .copy-feedback { animation: fadeUp 1.5s forwards; }
        @keyframes fadeUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-20px); } }
        .symbol-item .delete-btn { opacity: 0; transition: opacity 0.2s; }
        .symbol-item:hover .delete-btn { opacity: 1; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 2px; }
        .step-item { transition: all 0.3s ease; }
        .step-item:hover { transform: translateX(4px); background: rgba(255,255,255,0.03); }
        .power-bar-fill { transition: width 1s cubic-bezier(0.4, 0, 0.2, 1); }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- 1. STORAGE HOOK (Supabase Support) ---
        const useStorage = () => {
            const [supabase, setSupabase] = useState(null);
            const [symbols, setSymbols] = useState([]);
            const [config, setConfig] = useState({
                lineToken: localStorage.getItem('tw_line_token') || '',
                sbUrl: localStorage.getItem('tw_sb_url') || '',
                sbKey: localStorage.getItem('tw_sb_key') || ''
            });

            useEffect(() => {
                if (config.sbUrl && config.sbKey && window.supabase) {
                    try {
                        const client = window.supabase.createClient(config.sbUrl, config.sbKey);
                        setSupabase(client);
                        fetchSupabaseSymbols(client);
                    } catch (e) { loadLocalSymbols(); }
                } else { setSupabase(null); loadLocalSymbols(); }
            }, [config.sbUrl, config.sbKey]);

            const loadLocalSymbols = () => {
                const local = JSON.parse(localStorage.getItem('tw_symbols') || '[]');
                setSymbols(local);
            };

            const fetchSupabaseSymbols = async (client) => {
                const { data, error } = await client.from('symbols').select('*').order('created_at', { ascending: true });
                if (error) loadLocalSymbols(); else setSymbols(data || []);
            };

            const addSymbol = async (name) => {
                const newSym = { name, created_at: new Date().toISOString() };
                if (supabase) {
                    const { data, error } = await supabase.from('symbols').insert([newSym]).select();
                    if (!error && data) setSymbols([...symbols, data[0]]);
                } else {
                    const updated = [...symbols, { ...newSym, id: Date.now() }];
                    setSymbols(updated); localStorage.setItem('tw_symbols', JSON.stringify(updated));
                }
            };

            const removeSymbol = async (id) => {
                if (supabase) {
                    const { error } = await supabase.from('symbols').delete().eq('id', id);
                    if (!error) setSymbols(symbols.filter(s => s.id !== id));
                } else {
                    const updated = symbols.filter(s => s.id !== id);
                    setSymbols(updated); localStorage.setItem('tw_symbols', JSON.stringify(updated));
                }
            };

            const updateConfig = (key, value) => {
                localStorage.setItem(key, value);
                setConfig(prev => ({ ...prev, [key === 'tw_line_token' ? 'lineToken' : (key === 'tw_sb_url' ? 'sbUrl' : 'sbKey')]: value }));
            };

            return { symbols, addSymbol, removeSymbol, config, updateConfig, isCloud: !!supabase };
        };

        // --- 2. CORE MATH & INDICATORS ---
        const calculateSMA = (data, count) => data.map((d, i, arr) => i < count - 1 ? { time: d.time, value: NaN } : { time: d.time, value: arr.slice(i - count + 1, i + 1).reduce((acc, val) => acc + val.close, 0) / count }).filter(d => !isNaN(d.value));
        const calculateATR = (data, period = 14) => {
            let trs = []; for(let i=1; i<data.length; i++) trs.push(Math.max(data[i].high - data[i].low, Math.abs(data[i].high - data[i-1].close), Math.abs(data[i].low - data[i-1].close)));
            return trs.slice(-period).reduce((a, b) => a + b, 0) / period;
        };
        const calculateVWAP = (candles, volumes) => {
            let cumVol = 0, cumVolPrice = 0;
            return candles.map((c, i) => {
                const vol = volumes[i].value || 1; cumVol += vol; cumVolPrice += ((c.high + c.low + c.close) / 3 * vol);
                return { time: c.time, value: cumVolPrice / cumVol };
            });
        };
        const calculateRSI = (prices, period = 14) => {
            let gains = 0, losses = 0;
            for (let i = 1; i <= period; i++) {
                const change = prices[i] - prices[i - 1];
                if (change > 0) gains += change; else losses -= Math.abs(change);
            }
            let avgGain = gains / period; let avgLoss = losses / period;
            const rsiArray = []; for(let i=0; i<period; i++) rsiArray.push(50);
            for (let i = period + 1; i < prices.length; i++) {
                const change = prices[i] - prices[i - 1];
                avgGain = (avgGain * (period - 1) + (change > 0 ? change : 0)) / period;
                avgLoss = (avgLoss * (period - 1) + (change < 0 ? -change : 0)) / period;
                const rs = avgGain / avgLoss; rsiArray.push(100 - (100 / (1 + rs)));
            }
            return rsiArray;
        };
        const findDivergence = (prices, rsis, lookback = 15) => {
            if(prices.length < lookback || rsis.length < lookback) return null;
            const currPrice = prices[prices.length-1]; const prevPricePeak = Math.max(...prices.slice(prices.length-lookback, prices.length-2));
            const currRSI = rsis[rsis.length-1]; const prevRSIPeak = Math.max(...rsis.slice(rsis.length-lookback, rsis.length-2));
            if (currPrice > prevPricePeak && currRSI < prevRSIPeak && currRSI > 65) return "Bearish Divergence";
            
            const currPriceLow = prices[prices.length-1]; const prevPriceLow = Math.min(...prices.slice(prices.length-lookback, prices.length-2));
            const currRSILow = rsis[rsis.length-1]; const prevRSILow = Math.min(...rsis.slice(rsis.length-lookback, rsis.length-2));
            if (currPriceLow < prevPriceLow && currRSILow > prevRSILow && currRSILow < 35) return "Bullish Divergence";
            return null;
        };
        const findZones = (data, window = 20) => {
            let res = [], sup = [];
            for(let i = window; i < data.length - window; i++) {
                const c = data[i]; let isHigh = true, isLow = true;
                for(let j = 1; j <= window; j++) {
                    if(data[i-j].high > c.high || data[i+j].high > c.high) isHigh = false;
                    if(data[i-j].low < c.low || data[i+j].low < c.low) isLow = false;
                }
                if(isHigh) res.push(c.high); if(isLow) sup.push(c.low);
            }
            return { res: res.slice(-2), sup: sup.slice(-2) };
        };
        const findFVG = (candles) => {
            const fvgs = [];
            for(let i = candles.length - 2; i > candles.length - 50; i--) {
                const c = candles[i], prev = candles[i-1], next = candles[i+1];
                if(prev && next) {
                    if (c.close > c.open && next.low > prev.high) fvgs.push({ type: 'BULL', top: next.low, bottom: prev.high, time: c.time });
                    else if (c.close < c.open && next.high < prev.low) fvgs.push({ type: 'BEAR', top: prev.low, bottom: next.high, time: c.time });
                }
            }
            return fvgs.slice(0, 3);
        };

        // --- MASTER ANALYSIS ENGINE ---
        const analyzeMarketData = (candles, volumes) => {
            if (!candles || candles.length < 100) return null;
            const len = candles.length, c = candles[len - 1], body = Math.abs(c.close - c.open);
            
            // Indicators
            const smaData = calculateSMA(candles, 50);
            const lastSMA = smaData.length > 0 ? smaData[smaData.length-1].value : c.close;
            const atr = calculateATR(candles, 14);
            const vwapData = calculateVWAP(candles, volumes);
            const lastVWAP = vwapData.length > 0 ? vwapData[vwapData.length-1].value : c.close;
            const zones = findZones(candles);
            const fvgs = findFVG(candles);
            const prices = candles.map(x => x.close);
            const rsis = calculateRSI(prices);
            const divergence = findDivergence(prices, rsis);

            const vCurrent = volumes[len - 1].value;
            const volAvg = volumes.slice(len - 20).reduce((a, b) => a + b.value, 0) / 20;
            const isHighVol = vCurrent > volAvg * 1.3;

            let pattern = "Normal Candle";
            const isGreen = c.close > c.open;
            
            if (isGreen && c.close > candles[len-2].open && c.open < candles[len-2].close) pattern = "Bullish Engulfing";
            else if (!isGreen && c.close < candles[len-2].open && c.open > candles[len-2].close) pattern = "Bearish Engulfing";
            else if (((Math.min(c.open, c.close) - c.low) > body * 2) && ((c.high - Math.max(c.open, c.close)) < body * 0.6)) pattern = "Hammer";
            else if (((c.high - Math.max(c.open, c.close)) > body * 2) && ((Math.min(c.open, c.close) - c.low) < body * 0.6)) pattern = "Shooting Star";

            // Scoring
            let score = 50; 
            const isUptrend = c.close > lastSMA;
            
            // Generate Descriptions
            let trendDesc = `ราคา (${c.close.toLocaleString()}) ${isUptrend ? 'ยืนเหนือ' : 'อยู่ใต้'} เส้น SMA50`;
            if(divergence) trendDesc += ` และเกิดสัญญาณ ${divergence} (กลับตัว)`;

            if (c.close > lastSMA) score += 20; else score -= 20;
            if (c.close > lastVWAP) score += 10; else score -= 10;
            if (divergence === "Bullish Divergence") score += 25;
            if (divergence === "Bearish Divergence") score -= 25;
            
            let instDesc = `เทียบกับ VWAP: ${c.close > lastVWAP ? 'Bullish' : 'Bearish'}`;
            const nearSupport = zones.sup.some(z => Math.abs(c.close - z) / c.close < 0.01);
            const nearResistance = zones.res.some(z => Math.abs(c.close - z) / c.close < 0.01);
            
            if (nearSupport) { score += 20; instDesc += " + อยู่ใน Demand Zone"; } 
            else if (nearResistance) { score -= 20; instDesc += " + ชน Supply Zone"; }

            if (pattern.includes("Bullish") || pattern.includes("Hammer")) score += 15;
            else if (pattern.includes("Bearish") || pattern.includes("Shooting")) score -= 15;

            if (isHighVol) { if (isGreen) score += 5; else score -= 5; instDesc += " + High Volume"; }

            score = Math.max(5, Math.min(95, score));
            let bias = score >= 55 ? "BULLISH" : (score <= 45 ? "BEARISH" : "NEUTRAL");
            let action = score >= 65 ? "BUY" : (score <= 35 ? "SELL" : "WAIT");

            const slDist = atr * 2;
            const sl = action === 'BUY' || bias === 'BULLISH' ? c.close - slDist : c.close + slDist;
            const tp1 = action === 'BUY' || bias === 'BULLISH' ? c.close + slDist * 1.5 : c.close - slDist * 1.5;
            const tp2 = action === 'BUY' || bias === 'BULLISH' ? c.close + slDist * 3 : c.close - slDist * 3;

            return {
                candles, volumes, smaData, fvgs, zones, divergence,
                action, entry: c.close, sl, tp1, tp2,
                confidenceScore: score, bias, pattern,
                trendDesc, instDesc, lastVWAP
            };
        };

        const sendLineNotify = async (token, message) => {
            if (!token) return { success: false, error: "No Token" };
            const PROXY_URL = "https://corsproxy.io/?"; 
            const LINE_API = "https://notify-api.line.me/api/notify";
            try {
                const formData = new URLSearchParams(); formData
